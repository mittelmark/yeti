<!DOCTYPE html>
<html lang="" xml:lang="" xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta charset="utf-8"/>
<meta content="pandoc" name="generator"/>
<meta content="width=device-width, initial-scale=1.0, user-scalable=yes" name="viewport"/>
<title>yeti 0.4 documentation</title>
<style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
  </style>
<link href="data:text/css,%20%20%20%20html%20%7B%0A%20%20%20%20%20%20%20%20overflow-y%3A%20scroll%3B%0A%20%20%20%20%7D%0A%20%20%20%20body%20%7B%0A%20%20%20%20%20%20%20%20color%3A%20%23444%3B%0A%20%20%20%20%20%20%20%20font-family%3A%20Georgia%2C%20Palatino%2C%20%27Palatino%20Linotype%27%2C%20Times%2C%20%0A%20%20%20%20%20%20%20%20%20%20%20%27Times%20New%20Roman%27%2C%20serif%3B%0A%20%20%20%20%20%20%20%20line-height%3A%201.2%3B%0A%20%20%20%20%20%20%20%20padding%3A%201em%3B%0A%20%20%20%20%20%20%20%20margin%3A%20auto%3B%0A%20%20%20%20%20%20%20%20max-width%3A%20%201200px%3B%0A%20%20%20%20%7D%0A%20%20%20%20a%20%7B%0A%20%20%20%20%20%20%20%20color%3A%20%230645ad%3B%0A%20%20%20%20%20%20%20%20text-decoration%3A%20none%3B%0A%20%20%20%20%7D%0A%20%20%20%20a%3Avisited%20%7B%0A%20%20%20%20%20%20%20%20color%3A%20%230b0080%3B%0A%20%20%20%20%7D%0A%20%20%20%20a%3Ahover%20%7B%0A%20%20%20%20%20%20%20%20color%3A%20%2306e%3B%0A%20%20%20%20%7D%0A%20%20%20%20a%3Aactive%20%7B%0A%20%20%20%20%20%20%20%20color%3A%20%23faa700%3B%0A%20%20%20%20%7D%0A%20%20%20%20a%3Afocus%20%7B%0A%20%20%20%20%20%20%20%20outline%3A%20thin%20dotted%3B%0A%20%20%20%20%7D%0A%20%20%20%20p%20%7B%0A%20%20%20%20%20%20%20%20margin%3A%200.5em%200%3B%0A%20%20%20%20%7D%0A%20%20%20%20p.date%20%7B%0A%20%20%20%20%20%20%20%20text-align%3A%20center%3B%0A%20%20%20%20%7D%0A%20%20%20%20img%20%7B%0A%20%20%20%20%20%20%20%20max-width%3A%20100%25%3B%0A%20%20%20%20%7D%0A%20%20%20%20%0A%20%20%20%20h1%2C%20h2%2C%20h3%2C%20h4%2C%20h5%2C%20h6%20%7B%0A%20%20%20%20%20%20%20%20color%3A%20%23111%3B%0A%20%20%20%20%20%20%20%20line-height%3A%20115%25%3B%0A%20%20%20%20%20%20%20%20margin-top%3A%201em%3B%0A%20%20%20%20%20%20%20%20font-weight%3A%20normal%3B%0A%20%20%20%20%7D%0A%20%20%20%20h1%20%7B%0A%20%20%20%20%20%20%20%20font-size%3A%20120%25%3B%0A%20%20%20%20%20%20%20%20text-align%3A%20left%3B%0A%20%20%20%20%7D%0A%20%20%20%20h1.title%20%7B%0A%20%20%20%20%20%20%20%20font-size%3A%20140%25%3B%0A%20%20%20%20%20%20%20%20text-align%3A%20center%3B%0A%20%20%20%20%7D%0A%20%20%20%20%0A%20%20%20%20h2%20%7B%0A%20%20%20%20%20%20%20%20text-transform%3A%20uppercase%3B%0A%20%20%20%20%7D%0A%20%20%20%20pre%2C%20blockquote%20pre%20%7B%0A%20%20%20%20%20%20%20%20border-top%3A%200.1em%20%239ac%20solid%3B%0A%20%20%20%20%20%20%20%20background%3A%20%23e9f6ff%3B%0A%20%20%20%20%20%20%20%20padding%3A%2010px%3B%0A%20%20%20%20%20%20%20%20border-bottom%3A%200.1em%20%239ac%20solid%3B%0A%20%20%20%20%7D%0A%20%20%20%20%0A%20%20%20%20blockquote%20%7B%0A%20%20%20%20%20%20%20%20margin%3A%200%3B%0A%20%20%20%20%20%20%20%20padding-left%3A%203em%3B%20%0A%20%20%20%20%7D%0A%20%20%20%20%23cb1%20.tcl%20%7B%0A%20%20%20%20%20%20%20%20margin-left%3A%200em%3B%0A%20%20%20%20%7D%0A%20%20%20%20pre.tcl%20%7B%0A%20%20%20%20%20%20%20%20margin-left%3A%203em%3B%0A%20%20%20%20%20%20%20%20margin-right%3A%203em%3B%0A%20%20%20%20%7D%0A%20%20%20%20pre%20%7B%0A%20%20%20%20%20%20%20%20margin-left%3A%20%203em%3B%0A%20%20%20%20%20%20%20%20margin-right%3A%203em%3B%0A%20%20%20%20%7D%0A%20%20%20%20hr%20%7B%0A%20%20%20%20%20%20%20%20display%3A%20block%3B%0A%20%20%20%20%20%20%20%20height%3A%202px%3B%0A%20%20%20%20%20%20%20%20border%3A%200%3B%0A%20%20%20%20%20%20%20%20border-top%3A%201px%20solid%20%23aaa%3B%0A%20%20%20%20%20%20%20%20border-bottom%3A%201px%20solid%20%23eee%3B%0A%20%20%20%20%20%20%20%20margin%3A%201em%200%3B%0A%20%20%20%20%20%20%20%20padding%3A%200%3B%0A%20%20%20%20%7D%0A%20%20%20%20%0A%20%20%20%20pre%2C%20code%2C%20kbd%2C%20samp%20%7B%0A%20%20%20%20%20%20%20%20color%3A%20%23000%3B%0A%20%20%20%20%20%20%20%20font-family%3A%20Monaco%2C%20%27courier%20new%27%2C%20monospace%3B%0A%20%20%20%20%20%20%20%20font-size%3A%2090%25%3B%20%0A%20%20%20%20%7D%0A%20%20%20%20%0A%20%20%20%20pre%20%7B%0A%20%20%20%20%20%20%20%20white-space%3A%20pre%3B%0A%20%20%20%20%20%20%20%20white-space%3A%20pre-wrap%3B%0A%20%20%20%20%20%20%20%20word-wrap%3A%20break-word%3B%0A%20%20%20%20%7D%0A%20%20%20%20/%2A%20fix%2C%20do%20not%20like%20bold%20for%20every%20keyword%20%2A/%0A%20%20%20%20code%20span.kw%20%7B%20color%3A%20%23007020%3B%20font-weight%3A%20normal%3B%20%7D%20/%2A%20Keyword%20%2A/%0A%20%20%20%20%20pre.sourceCode%20%7B%0A%20%20%20%20%20%20%20%20background%3A%20%23fff6f6%3B%0A%20%20%20%20%7D%20%0A%20%20%20%20figure%2C%20p.author%20%7B%0A%20%20%20%20%20%20%20%20text-align%3A%20center%3B%0A%20%20%20%20%7D%0A%20%20%20%20table%20%7B%0A%20%20%20%20%20%20%20%20min-width%3A%20300px%3B%0A%20%20%20%20%20%20%20%20border-spacing%3A%200%3B%0A%20%20%20%20%20%20%20%20border-collapse%3A%20collapse%3B%0A%20%20%20%20%20%20%20%20cell-padding%3A%200px%3B%0A%20%20%20%20%20%20%20%20cell-spacing%3A%200px%3B%0A%20%20%20%20%7D%0A%20%20%20%20tr.header%20%7B%0A%20%20%20%20%20%20%20%20background%3A%20%23dddddd%3B%0A%20%20%20%20%20%20%20%20text-align%3A%20center%3B%0A%20%20%20%20%7D%0A%20%20%20%20tr.even%20%7B%0A%20%20%20%20%20%20%20%20background%3A%20%23ddeeff%3B%0A%20%20%20%20%7D%0A%20%20%20%20td%2C%20th%20%7B%0A%20%20%20%20%20%20%20%20padding%3A%203px%3B%0A%20%20%20%20%20%20%20%20text-align%3A%20center%3B%0A%20%20%20%20%7D%0A" rel="stylesheet"/><!--URL:mini.css-->
<!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<header id="title-block-header">
<h1 class="title">yeti 0.4 documentation</h1>
<p class="date">0.4</p>
</header>
<h1>NAME</h1>
<p>Ylex - Yeti's Scanner</p>
<h1>SYNOPSIS</h1>
<p><strong>package require ylex ?0.4?</strong></p>
<p><strong>yeti::ylex</strong> <em>name</em></p>
<p><em>name</em> <strong>macro</strong> <em>name</em> <em>regex</em> ?<em>...?</em></p>
<p><em>name</em> <strong>macro</strong> <em>args</em></p>
<p><em>name</em> <strong>add</strong> ?<em>options</em>? <em>regex</em> <em>script</em> ?<em>...?</em></p>
<p><em>name</em> <strong>add</strong> ?<em>options</em>? <em>args</em></p>
<p><em>name</em> <strong>code</strong> <em>token</em> <em>script</em></p>
<p><em>name</em> <strong>dump</strong></p>
<p><em>name</em> <strong>configure</strong> <strong>-name</strong> ?<em>value</em>?</p>
<p><em>name</em> <strong>configure</strong> <strong>-start</strong> ?<em>value</em>?</p>
<p><em>name</em> <strong>configure</strong> <strong>-case</strong> ?<em>value</em>?</p>
<h1>SCANNER SYNOPSIS</h1>
<p><em>scannerName</em> <em>objName</em> ?<em>options</em>?</p>
<p><em>name</em> <strong>start</strong> <em>string</em></p>
<p><em>name</em> <strong>reset</strong></p>
<p><em>name</em> <strong>next</strong></p>
<p><em>name</em> <strong>step</strong></p>
<p><em>name</em> <strong>run</strong></p>
<p><em>name</em> <strong>configure</strong> <strong>-case</strong> ?<em>value</em>?</p>
<p><em>name</em> <strong>configure</strong> <strong>-yydata</strong> ?<em>value</em>?</p>
<p><em>name</em> <strong>configure</strong> <strong>-verbose</strong> ?<em>value</em>?</p>
<p><em>name</em> <strong>configure</strong> <strong>-verbout</strong> ?<em>value</em>?</p>
<h1>DESCRIPTION</h1>
<p>This manual page describes <strong>ylex</strong>, a scanner generator that comes with the <strong>yeti</strong> package. <strong>ylex</strong> is modeled after the standard <strong>lex</strong> utility, which is used to create scanners in the C programming language.</p>
<p>A scanner consists of a number of rules. Each rule associates a regular expression with a Tcl script; this script is executed whenever the regular expression is matched in the input. This code can either act on its own, or it can generate a stream of tokens that can then be evaluated outside of the scanner - e.g. in a parser.</p>
<p><strong>ylex</strong> does not do the scanning by itself, rather it is used, quite like <strong>lex</strong>, to generate scanners (by way of the <strong>dump</strong> method). Generated scanners are <strong>[incr Tcl]</strong> classes that act independently of <strong>ylex</strong>, see the <strong>Scanner</strong> section below. These scanners can be customized; you can use the <strong>code</strong> method to add user variables and methods to the class.</p>
<h1>COMMANDS</h1>
<dl>
<dt><strong>yeti::ylex</strong> <em>name</em></dt>
<dd><p>Creates a new scanner generator by the name of <em>name</em>. The new scanner generator has an empty set of rules. <em>options</em> can be used to configure the scanner generator's public variables, see the <em>variables</em> section below.</p>
</dd>
</dl>
<h1>METHODS</h1>
<dl>
<dt><em>name</em> <strong>macro</strong> <em>name</em> <em>regex</em> ?<em>...?</em></dt>
<dd>
</dd>
<dt><em>name</em> <strong>macro</strong> <em>args</em></dt>
<dd>
</dd>
</dl>
<p>Defines <em>macros</em>, which are regular expressions that are stored for later use. Macros can be used in other macros or rules using their name in angular brackets, e.g. <em>&lt;digit&gt;</em> would reference the <em>digit</em> macro. Macro names must be alphanumerical. In the first form, the <strong>macro</strong> method takes an even number of parameters. The first parameter of each pair is the name, the second parameter is a regular expression that may itself contain other macros. In the second form, the method takes a list as single parameter, where this list is composed as above of alternating names and regular expressions. The second form may be more convenient to define multiple macros.</p>
<dl>
<dt><em>name</em> <strong>add</strong> ?<em>options</em>? <em>regex</em> <em>script</em> ?<em>...?</em></dt>
<dd>
</dd>
</dl>
<dl>
<dt><em>name</em> <strong>add</strong> ?<em>options</em>? <em>args</em></dt>
<dd>
</dd>
</dl>
<p>Adds new rules to the scanner. In the first form, the <strong>add</strong> method takes an even number of parameters (not counting options). The first parameter of each pair is a regular expression, the second parameter is a script. In the second form, the method takes a list as single parameter (not counting options), where this list is composed as above of alternating regular expressions and scripts.</p>
<blockquote>
<p>Whenever the regular expression <em>regex</em> is matched in the input string, its corresponding <em>script</em> will be executed by the scanner.</p>
<p>The following options are supported:</p>
<ul>
<li><p>This option has the same meaning as on <strong>regexp</strong>. In matching this rule, upper-case characters in the input will be treated as lower-case.</p></li>
<li><p>This rule will only be considered if the scanner is in the state <em>name</em>. See below for more information.</p></li>
<li><p>Same as above, but <em>names</em> is a list of state names in which the rule is active.</p></li>
</ul>
</blockquote>
<dl>
<dt><em>name</em> <strong>code</strong> <em>token</em> <em>script</em></dt>
<dd><p>Adds custom user code to the generated scanner. <em>token</em> must be one of</p>
<ul>
<li><p>Defines the class's constructor. The <em>script</em> may have any of the formats allowed by <strong>[incr Tcl]</strong>, without the <strong>constructor</strong> keyword.</p></li>
<li><p>Defines the body of the class's destructor.</p></li>
<li><p>Defines the body of the error handler that is called whenever an error occurs, e.g. errors executing a rule's script. <em>script</em> has access to the <strong>yyerrmsg</strong> parameter, which contains a string with a description of the error and its cause. <em>script</em> is supposed to inform the user of the problem. The default implementations prints the message to the channel set in the <strong>verbout</strong> variable. <em>script</em> is expected to return normally; the parser then returns from the current invocation with the original error.</p></li>
<li><p>The <em>script</em> is added to the body of the scanner's <em>reset</em> method.</p></li>
<li></li>
</ul>
<ul>
<li></li>
<li><p>Defines public, protected or private class members. The <em>script</em> may contain many different member definitions, like the respective keywords in an <strong>[incr Tcl]</strong> class definition.</p></li>
</ul>
</dd>
<dt><em>name</em> <strong>dump</strong></dt>
<dd><p>Returns a script containing the generated scanner. This method is called after all configuration options have been set and all rules have been added; the scanner generator object is usually deleted after this method has been called. The returned script can be passed to <strong>eval</strong> for instant usage, or saved to a file, from where it can later be sourced without involvement of the scanner generator.</p>
</dd>
</dl>
<h1>VARIABLES</h1>
<dl>
<dt><em>name</em> <strong>configure</strong> <strong>-name</strong> ?<em>value</em>?</dt>
<dd><p>Defines the class name of the generated scanner class. The default value is <strong>unnamed</strong>.</p>
</dd>
<dt><em>name</em> <strong>configure</strong> <strong>-start</strong> ?<em>value</em>?</dt>
<dd><p>Defines the initial state for the scanner. Setting this variable is only required if your scanner needs multiple states, and you are not satisfied with the default of <strong>INITIAL</strong>.</p>
</dd>
<dt><em>name</em> <strong>configure</strong> <strong>-case</strong> ?<em>value</em>?</dt>
<dd><p>If set to 0 (zero), the generated scanner will be case-insensitive (i.e. <strong>-nocase</strong> will be used on all calls to <strong>regexp</strong>). The default value is 1 for a case-sensitive scanner. This setting can be overridden on a rule-by-rule basis using the <strong>-nocase</strong> option upon adding a rule.</p>
</dd>
</dl>
<h1>SCANNER USAGE</h1>
<p>Scanners are independent of <strong>ylex</strong>, their only dependency is on <strong>[incr Tcl]</strong>.</p>
<p>A scanner reads its input from a string that must be set before scanning can begin. The regular expressions (rules) are then repeatedly matched against the current input position within this string. If more than one regular expression matches text at a certain position, the rule matching the most text is selected. If more than one regular expression matches the same amount of text, the rule that was added to the scanner generator first is selected. If a rule matches, its associated <em>script</em> is executed, and the read pointer is moved beyond the match. Unmatched text in the input is ignored and skipped.</p>
<p>Scanners are <strong>[incr Tcl]</strong> objects, so its usual rules of object handling (e.g. deletion of scanners) apply.</p>
<h1>SCANNER COMMANDS</h1>
<dl>
<dt><em>scannerName</em> <em>objName</em> ?<em>options</em>?</dt>
<dd><p>Creates a new scanner instance by the name of <em>objName</em>. <em>options</em> can be used to configure the scanner's public variables, see the <em>scanner variables</em> section below.</p>
</dd>
</dl>
<h1>SCANNER METHODS</h1>
<dl>
<dt><em>objName</em> <strong>start</strong> <em>string</em></dt>
<dd><p>Initializes the scanner to scan <em>string</em>. Calling <strong>start</strong> implies <strong>reset</strong>.</p>
</dd>
<dt><em>objName</em> <strong>reset</strong></dt>
<dd><p>Resets the scanner to the beginning of the input string, and resets the state to the initial state. If you want to scan a different string, you need not call <strong>reset</strong> but only <strong>start</strong>.</p>
</dd>
<dt><em>objName</em> <strong>next</strong></dt>
<dd><p>Starts the scanning process. Regular expressions are matched, and their scripts are executed. This repeats until a script executes <strong>return</strong> or until end of input is reached. If a script executes <strong>return</strong>, the script's return value is returned. At the end of input, an empty string is returned.</p>
</dd>
<dt><em>objName</em> <strong>step</strong></dt>
<dd><p>Single-steps the parser. This method returns after a single match has been done, regardless of whether its script executed <strong>return</strong> or not. <strong>step</strong> returns a list of length three. The first element of this list is the number of the rule that was matched or -1 if at the end of input. The second element is 1 if the script executed <strong>return</strong>, 0 otherwise. The third element is the script's return value if the script executed <strong>return</strong>, empty otherwise.</p>
</dd>
<dt><em>objName</em> <strong>run</strong></dt>
<dd><p>Runs the scanning process to completion. <strong>next</strong> is repeatedly called until the end of input has been reached. A list of all the results returned from <strong>next</strong> is returned.</p>
</dd>
</dl>
<h1>SCANNER VARIABLES</h1>
<dl>
<dt><em>objName</em> <strong>configure</strong> <strong>-case</strong> ?<em>value</em>?</dt>
<dd><p>If this variable is zero, then the <strong>-nocase</strong> option is implicitly set for all rules. The default value is determined by the setting of the <strong>case</strong> variable in the scanner generator. Setting this variable after scanning has started may yield unexpected results because of cached data.</p>
</dd>
<dt><em>objName</em> <strong>configure</strong> <strong>-yydata</strong> ?<em>value</em>?</dt>
<dd><p>This variable holds the input string. This variable is not meant to be modified, but it can be conveniently configured upon object creation. If that is done, there is no need to call the <strong>start</strong> method.</p>
</dd>
<dt><em>objName</em> <strong>configure</strong> <strong>-yyindex</strong> ?<em>value</em>?</dt>
<dd><p>This variable holds the current index into the input string. This variable is not meant to be set, but reading it may be useful e.g. to determine the position that causes an error in a parser. After an invocation <strong>step</strong> or <strong>next</strong>, <strong>yyindex</strong> points to the character after the current match.</p>
</dd>
<dt><em>objName</em> <strong>configure</strong> <strong>-verbose</strong> ?<em>value</em>?</dt>
<dd><p>If this value is non-zero, the scanner prints debug information about its processing. The larger <strong>verbose</strong> is, the more information is printed (sensible values are 0 to 3). By default, no debug information is printed.</p>
</dd>
<dt><em>objName</em> <strong>configure</strong> <strong>-verbout</strong> ?<em>value</em>?</dt>
<dd><p>This variable contains the channel that is used for debug output. By default, this is <strong>stderr</strong>.</p>
</dd>
</dl>
<h1>SCRIPTS</h1>
<p>Scripts are executed in the context of the scanner. Scripts have access to the following variables.</p>
<dl>
<dt><strong>yytext</strong></dt>
<dd><p>This variable contains the text that was matched by the regular expression.</p>
</dd>
<dt><strong>yystate</strong></dt>
<dd><p>This variable contains the current state of the scanner. The script may modify this variable to switch the scanner to a different state.</p>
</dd>
<dt><strong>yystart</strong></dt>
<dd><p>The absolute index of the first character of the current match.</p>
</dd>
<dt><strong>yyend</strong></dt>
<dd><p>The absolute index of the last character of the current match.</p>
</dd>
<dt><em>&lt;i&gt;</em></dt>
<dd><p>These variables (<strong>$1</strong>, <strong>$2</strong> ...) contain any subexpressions matched by the regular expression.</p>
</dd>
</dl>
<p><strong>ylex</strong> reserves names with the <strong>yy</strong> prefix, so scripts should not use or access variables with this prefix other than those documented here. Also, a scanner's public methods and variables as seen above must be respected.</p>
<h1>STATES</h1>
<p>Initially, a scanner is in the initial state as determined by the <strong>start</strong> variable of the scanner generator. Scripts can switch to a different state by modifying the <strong>yystate</strong> variable during execution of a script. In each state, only a subset of all rules will be considered, as determined by the <strong>-state</strong> or <strong>-states</strong> options upon adding rules to the scanner generator; if no such option was used when adding a rule, it will be active in all states.</p>
<h1>NOTES</h1>
<p>Unmatched text in the input is ignored. In order to throw an error upon unmatched text, add a "catch-all" rule at the end of the rule set (usually with the regular expression "." that matches any character).</p>
<p>Subexpressions are available in the <em>$&lt;i&gt;</em> variables only when using Tcl 8.3 or above.</p>
<p>It is illegal to have rules that match the empty string.</p>
<h1>TODO</h1>
<p>There should be a means of reading data from elsewhere than a string. It might be inconvenient to have all the input in memory. However, that is not possible with the current regexp engine.</p>
<p>Maybe there should be the possibility to read a lex-like input file.</p>
<h1>KEYWORDS</h1>
<p>scanner, parser, token</p>
</body>
</html><!--Generated by HTMLArk 2021-10-03 18:00:25.788643. Original URL ylex-out.html-->
