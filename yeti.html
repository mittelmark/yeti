<!DOCTYPE html>
<html lang="" xml:lang="" xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta charset="utf-8"/>
<meta content="pandoc" name="generator"/>
<meta content="width=device-width, initial-scale=1.0, user-scalable=yes" name="viewport"/>
<title>yeti 0.4 documentation</title>
<style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
  </style>
<link href="data:text/css,%20%20%20%20html%20%7B%0A%20%20%20%20%20%20%20%20overflow-y%3A%20scroll%3B%0A%20%20%20%20%7D%0A%20%20%20%20body%20%7B%0A%20%20%20%20%20%20%20%20color%3A%20%23444%3B%0A%20%20%20%20%20%20%20%20font-family%3A%20Georgia%2C%20Palatino%2C%20%27Palatino%20Linotype%27%2C%20Times%2C%20%0A%20%20%20%20%20%20%20%20%20%20%20%27Times%20New%20Roman%27%2C%20serif%3B%0A%20%20%20%20%20%20%20%20line-height%3A%201.2%3B%0A%20%20%20%20%20%20%20%20padding%3A%201em%3B%0A%20%20%20%20%20%20%20%20margin%3A%20auto%3B%0A%20%20%20%20%20%20%20%20max-width%3A%20%201200px%3B%0A%20%20%20%20%7D%0A%20%20%20%20a%20%7B%0A%20%20%20%20%20%20%20%20color%3A%20%230645ad%3B%0A%20%20%20%20%20%20%20%20text-decoration%3A%20none%3B%0A%20%20%20%20%7D%0A%20%20%20%20a%3Avisited%20%7B%0A%20%20%20%20%20%20%20%20color%3A%20%230b0080%3B%0A%20%20%20%20%7D%0A%20%20%20%20a%3Ahover%20%7B%0A%20%20%20%20%20%20%20%20color%3A%20%2306e%3B%0A%20%20%20%20%7D%0A%20%20%20%20a%3Aactive%20%7B%0A%20%20%20%20%20%20%20%20color%3A%20%23faa700%3B%0A%20%20%20%20%7D%0A%20%20%20%20a%3Afocus%20%7B%0A%20%20%20%20%20%20%20%20outline%3A%20thin%20dotted%3B%0A%20%20%20%20%7D%0A%20%20%20%20p%20%7B%0A%20%20%20%20%20%20%20%20margin%3A%200.5em%200%3B%0A%20%20%20%20%7D%0A%20%20%20%20p.date%20%7B%0A%20%20%20%20%20%20%20%20text-align%3A%20center%3B%0A%20%20%20%20%7D%0A%20%20%20%20img%20%7B%0A%20%20%20%20%20%20%20%20max-width%3A%20100%25%3B%0A%20%20%20%20%7D%0A%20%20%20%20%0A%20%20%20%20h1%2C%20h2%2C%20h3%2C%20h4%2C%20h5%2C%20h6%20%7B%0A%20%20%20%20%20%20%20%20color%3A%20%23111%3B%0A%20%20%20%20%20%20%20%20line-height%3A%20115%25%3B%0A%20%20%20%20%20%20%20%20margin-top%3A%201em%3B%0A%20%20%20%20%20%20%20%20font-weight%3A%20normal%3B%0A%20%20%20%20%7D%0A%20%20%20%20h1%20%7B%0A%20%20%20%20%20%20%20%20font-size%3A%20120%25%3B%0A%20%20%20%20%20%20%20%20text-align%3A%20left%3B%0A%20%20%20%20%7D%0A%20%20%20%20h1.title%20%7B%0A%20%20%20%20%20%20%20%20font-size%3A%20140%25%3B%0A%20%20%20%20%20%20%20%20text-align%3A%20center%3B%0A%20%20%20%20%7D%0A%20%20%20%20%0A%20%20%20%20h2%20%7B%0A%20%20%20%20%20%20%20%20text-transform%3A%20uppercase%3B%0A%20%20%20%20%7D%0A%20%20%20%20pre%2C%20blockquote%20pre%20%7B%0A%20%20%20%20%20%20%20%20border-top%3A%200.1em%20%239ac%20solid%3B%0A%20%20%20%20%20%20%20%20background%3A%20%23e9f6ff%3B%0A%20%20%20%20%20%20%20%20padding%3A%2010px%3B%0A%20%20%20%20%20%20%20%20border-bottom%3A%200.1em%20%239ac%20solid%3B%0A%20%20%20%20%7D%0A%20%20%20%20%0A%20%20%20%20blockquote%20%7B%0A%20%20%20%20%20%20%20%20margin%3A%200%3B%0A%20%20%20%20%20%20%20%20padding-left%3A%203em%3B%20%0A%20%20%20%20%7D%0A%20%20%20%20%23cb1%20.tcl%20%7B%0A%20%20%20%20%20%20%20%20margin-left%3A%200em%3B%0A%20%20%20%20%7D%0A%20%20%20%20pre.tcl%20%7B%0A%20%20%20%20%20%20%20%20margin-left%3A%203em%3B%0A%20%20%20%20%20%20%20%20margin-right%3A%203em%3B%0A%20%20%20%20%7D%0A%20%20%20%20pre%20%7B%0A%20%20%20%20%20%20%20%20margin-left%3A%20%203em%3B%0A%20%20%20%20%20%20%20%20margin-right%3A%203em%3B%0A%20%20%20%20%7D%0A%20%20%20%20hr%20%7B%0A%20%20%20%20%20%20%20%20display%3A%20block%3B%0A%20%20%20%20%20%20%20%20height%3A%202px%3B%0A%20%20%20%20%20%20%20%20border%3A%200%3B%0A%20%20%20%20%20%20%20%20border-top%3A%201px%20solid%20%23aaa%3B%0A%20%20%20%20%20%20%20%20border-bottom%3A%201px%20solid%20%23eee%3B%0A%20%20%20%20%20%20%20%20margin%3A%201em%200%3B%0A%20%20%20%20%20%20%20%20padding%3A%200%3B%0A%20%20%20%20%7D%0A%20%20%20%20%0A%20%20%20%20pre%2C%20code%2C%20kbd%2C%20samp%20%7B%0A%20%20%20%20%20%20%20%20color%3A%20%23000%3B%0A%20%20%20%20%20%20%20%20font-family%3A%20Monaco%2C%20%27courier%20new%27%2C%20monospace%3B%0A%20%20%20%20%20%20%20%20font-size%3A%2090%25%3B%20%0A%20%20%20%20%7D%0A%20%20%20%20%0A%20%20%20%20pre%20%7B%0A%20%20%20%20%20%20%20%20white-space%3A%20pre%3B%0A%20%20%20%20%20%20%20%20white-space%3A%20pre-wrap%3B%0A%20%20%20%20%20%20%20%20word-wrap%3A%20break-word%3B%0A%20%20%20%20%7D%0A%20%20%20%20/%2A%20fix%2C%20do%20not%20like%20bold%20for%20every%20keyword%20%2A/%0A%20%20%20%20code%20span.kw%20%7B%20color%3A%20%23007020%3B%20font-weight%3A%20normal%3B%20%7D%20/%2A%20Keyword%20%2A/%0A%20%20%20%20%20pre.sourceCode%20%7B%0A%20%20%20%20%20%20%20%20background%3A%20%23fff6f6%3B%0A%20%20%20%20%7D%20%0A%20%20%20%20figure%2C%20p.author%20%7B%0A%20%20%20%20%20%20%20%20text-align%3A%20center%3B%0A%20%20%20%20%7D%0A%20%20%20%20table%20%7B%0A%20%20%20%20%20%20%20%20min-width%3A%20300px%3B%0A%20%20%20%20%20%20%20%20border-spacing%3A%200%3B%0A%20%20%20%20%20%20%20%20border-collapse%3A%20collapse%3B%0A%20%20%20%20%20%20%20%20cell-padding%3A%200px%3B%0A%20%20%20%20%20%20%20%20cell-spacing%3A%200px%3B%0A%20%20%20%20%7D%0A%20%20%20%20tr.header%20%7B%0A%20%20%20%20%20%20%20%20background%3A%20%23dddddd%3B%0A%20%20%20%20%20%20%20%20text-align%3A%20center%3B%0A%20%20%20%20%7D%0A%20%20%20%20tr.even%20%7B%0A%20%20%20%20%20%20%20%20background%3A%20%23ddeeff%3B%0A%20%20%20%20%7D%0A%20%20%20%20td%2C%20th%20%7B%0A%20%20%20%20%20%20%20%20padding%3A%203px%3B%0A%20%20%20%20%20%20%20%20text-align%3A%20center%3B%0A%20%20%20%20%7D%0A" rel="stylesheet"/><!--URL:mini.css-->
<!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<header id="title-block-header">
<h1 class="title">yeti 0.4 documentation</h1>
<p class="date">0.4</p>
</header>
<h1>NAME</h1>
<p>Yeti - Yet another Tcl Interpreter</p>
<h1>SYNOPSIS</h1>
<p><strong>package require yeti ?0.4?</strong></p>
<p><strong>yeti::yeti</strong> <em>name</em> ?<em>options</em>?</p>
<p><em>name</em> <strong>add</strong> <em>lhs</em> <em>rhs</em> ?<em>script</em>?</p>
<p><em>name</em> <strong>add</strong> <em>args</em></p>
<p><em>name</em> <strong>code</strong> <em>token</em> <em>script</em></p>
<p><em>name</em> <strong>dump</strong></p>
<p><em>name</em> <strong>configure</strong> <strong>-name</strong> ?<em>value</em>?</p>
<p><em>name</em> <strong>configure</strong> <strong>-start</strong> ?<em>value</em>?</p>
<p><em>name</em> <strong>configure</strong> <strong>-verbose</strong> ?<em>value</em>?</p>
<p><em>name</em> <strong>configure</strong> <strong>-verbout</strong> ?<em>value</em>?</p>
<h1>PARSER SYNOPSIS</h1>
<p><em>parserName</em> <em>objName</em> ?<em>options</em>?</p>
<p><em>objName</em> <strong>parse</strong></p>
<p><em>objName</em> <strong>step</strong></p>
<p><em>objName</em> <strong>reset</strong></p>
<p><em>objName</em> <strong>configure</strong> <strong>-scanner</strong> ?<em>object</em>?</p>
<p><em>objName</em> <strong>configure</strong> <strong>-verbose</strong> ?<em>value</em>?</p>
<h1>DESCRIPTION</h1>
<p>This manual page describes <strong>yeti</strong>, a parser generator that is modeled after the standard <strong>yacc</strong> package (and its incarnation as GNU <strong>bison</strong>), which is used to create parsers in the C programming language.</p>
<p>Parsers are used to parse an input (a stream of terminals) according to a <em>grammar</em>. This grammar is defined by a number of <em>rules</em>. <strong>yeti</strong> supports a subclass of context-free grammars named LALR(1), which is the class of context-free grammars that can be parsed using a single lookahead token.</p>
<p>Rules in <strong>yeti</strong> are written similar to the Backus-Naur Form (BNF). Rules have a <em>non-terminal</em> as left-hand side (LHS) and a list of non-terminals and <em>terminals</em> on the right-hand side (RHS). Non-terminals are parsed according to these rules, while terminals are read from the input. This way, all non-terminals are ultimately decomposed into sequences of terminals. There may be multiple rules with the same non-terminal on the LHS but different RHSs. The RHS may be empty.</p>
<p><strong>yeti</strong> does not do the parsing by itself, rather it is used, quite like <strong>yacc</strong>, to generate parsers (by way of the <strong>dump</strong> method). Generated parsers are <strong>[incr Tcl]</strong> classes that act independently of <strong>yeti</strong>, see the <strong>Parser</strong> section below. These parsers can be customized; you can use the <strong>code</strong> method to add user variables and methods to the class.</p>
<h1>COMMANDS</h1>
<dl>
<dt><strong>yeti::yeti</strong> <em>name</em> ?<em>options</em>?</dt>
<dd><p>Creates a new parser generator by the name of <em>name</em>. The new parser generator has an empty set of rules. <em>options</em> can be used to configure the parser generator's public variables, see the <em>variables</em> section below.</p>
</dd>
</dl>
<h1>METHODS</h1>
<dl>
<dt><em>name</em> <strong>add</strong> <em>lhs</em> <em>rhs</em> ?<em>script</em>?</dt>
<dd>
</dd>
</dl>
<dl>
<dt><em>name</em> <strong>add</strong> <em>args</em></dt>
<dd>
</dd>
</dl>
<p>Adds new rules to the parser. In the first form, <em>lhs</em> is a non-terminal, <em>rhs</em> is a (possibly empty) list of terminals and non-terminals. If this rule is matched, <em>script</em> is executed. In the second form, <em>args</em> is a list consisting of triplets, so the number of elements must be divisible by three. Each triplet represents a rule. The first element of each triplet is the <em>lhs</em>, the second element is the <em>rhs</em>, and the third element is a <em>script</em>, as above. In the second and following triplets, <strong>|</strong> (vertical bar, pipe symbol) can be used as <em>lhs</em>, referring to the <em>lhs</em> of the previous rule. The minus sign <strong>-</strong> can be used for <em>code</em> to indicate that no script is associated with this rule. If a rule is matched, its corresponding script is executed, see the <strong>scripts</strong> section below.</p>
<dl>
<dt><em>name</em> <strong>code</strong> <em>token</em> <em>script</em></dt>
<dd><p>Adds custom user code to the generated parser. <em>token</em> must be one of</p>
<ul>
<li><p>Defines the class's constructor. The <em>script</em> may have any of the formats allowed by <strong>[incr Tcl]</strong>, without the <strong>constructor</strong> keyword.</p></li>
<li><p>Defines the body of the class's destructor.</p></li>
<li><p>Defines the body of the error handler that is called whenever an error occurs, e.g. parse errors or errors executing a rule's script. <em>script</em> has access to the <strong>yyerrmsg</strong> parameter, which contains a string with a description of the error and its cause. <em>script</em> is supposed to inform the user of the problem. The default implementations prints the message to the channel set in the <strong>verbout</strong> variable. <em>script</em> is expected to return normally; the parser then returns from the current invocation with the original error.</p></li>
<li><p>The <em>script</em> is added to the body of the parser's <em>reset</em> method.</p></li>
<li></li>
</ul>
<ul>
<li></li>
<li><p>Defines public, protected or private class members. The <em>script</em> may contain many different member definitions, like the respective keywords in an <strong>[incr Tcl]</strong> class definition.</p></li>
</ul>
</dd>
<dt><em>name</em> <strong>dump</strong></dt>
<dd><p>Returns a script containing the generated parser. This method is called after all configuration options have been set and all rules have been added; the parser generator object is usually deleted after this method has been called. The returned script can be passed to <strong>eval</strong> for instant usage, or saved to a file, from where it can later be sourced without involvement of the parser generator.</p>
</dd>
</dl>
<h1>VARIABLES</h1>
<dl>
<dt><em>name</em> <strong>configure</strong> <strong>-name</strong> ?<em>value</em>?</dt>
<dd><p>Defines the class name of the generated parser class. The default value is <strong>unnamed</strong>.</p>
</dd>
<dt><em>name</em> <strong>configure</strong> <strong>-start</strong> ?<em>value</em>?</dt>
<dd><p>Defines the starting non-terminal for the parser. There must be at least one rule with this starting non-terminal as the left hand side. The default value is <strong>start</strong>.</p>
</dd>
<dt><em>name</em> <strong>configure</strong> <strong>-verbose</strong> ?<em>value</em>?</dt>
<dd><p>If the value of the <strong>verbose</strong> variable is non-zero, the parser prints some debug information about the generated parser, like the state machines that are generated from the rule set.</p>
</dd>
<dt><em>name</em> <strong>configure</strong> <strong>-verbout</strong> ?<em>value</em>?</dt>
<dd><p>Sets the target channel for debug information. The default value is <strong>stderr</strong>.</p>
</dd>
</dl>
<h1>NOTES</h1>
<p>No checks are done whether all non-terminals are reachable. Also, no checks are done to ensure that all non-terminals are defined, i.e. there is at least one rule with the non-terminal as LHS.</p>
<p>Using uppercase names for terminals and lowercase names for non-terminals is a common convention that is not enforced, and <strong>yeti</strong> assumes all undefined tokens to be terminals.</p>
<p>Set the <em>verbose</em> variable to a positive value to see warnings about reduce/reduce conflicts. Shift/reduce conflicts are not reported; <strong>yeti</strong> always prefers shifts over reductions.</p>
<h1>PARSER USAGE</h1>
<p>Parsers are independent of <strong>yeti</strong>, their only dependency is on <strong>[incr Tcl]</strong>.</p>
<p>Parsers read terminals from a <em>scanner</em> and try to match them against the rule set. Starting from the <strong>start</strong> non-terminal, the parser looks for a rule that accepts the terminal. Whenever a rule is matched, the script associated with the rule is executed. The values for each element on the RHS are made available to the script in the variables <strong>$</strong><em>&lt;i&gt;</em>, where <em>&lt;i&gt;</em> is the index of the item. The script can use these values to compute its own result.</p>
<p>Values for terminals are read from the <em>scanner</em>, values for non-terminals are the return values of the code associated with a rule that produced the non-terminal. If the code does not execute a <strong>return</strong>, or if there is no code associated with a rule, the value of the leftmost item on the RHS (<strong>$1</strong>) is used as result (see the example below).</p>
<p>Parsers are <strong>[incr Tcl]</strong> objects, so its usual rules of object handling (e.g. deletion of parsers) apply.</p>
<h1>PARSER COMMANDS</h1>
<dl>
<dt><em>parserName</em> <em>objName</em> ?<em>options</em>?</dt>
<dd><p>Creates a new parser instance by the name of <em>objName</em>. <em>options</em> can be used to configure the parser's public variables, see the <em>parser variables</em> section below.</p>
</dd>
</dl>
<h1>PARSER METHODS</h1>
<dl>
<dt><em>objName</em> <strong>parse</strong></dt>
<dd><p>Runs the parser. Tokens are read from the scanner as necessary and matched against terminals. The parsing process runs to completion, i.e. until a rule for the <strong>start</strong> token has been executed and the end of input has been reached. The value returned from the last rule is returned as result of <strong>parse</strong>, but it is also very common for parsers to leave data in variables rather than returning a result.</p>
</dd>
<dt><em>objName</em> <strong>step</strong></dt>
<dd><p>Single-steps the parser. One step is either the shifting of a token or a reduction. This method may be useful e.g. to do other work in parallel to the parsing. The method returns a list of length two; the first element is the token just shifted or reduced, and the second element is the associated data. Parsing is finished if the token <strong>__init__</strong> has been reduced.</p>
</dd>
<dt><em>objName</em> <strong>reset</strong></dt>
<dd><p>Resets the parser to the initial state, e.g. to start parsing new input. The scanner must be reset or replaced separately.</p>
</dd>
</dl>
<h1>PARSER VARIABLES</h1>
<dl>
<dt><em>objName</em> <strong>configure</strong> <strong>-scanner</strong> ?<em>object</em>?</dt>
<dd><p>The <strong>scanner</strong> variable holds the scanner from which terminals are read. The scanner must be configured before parsing can begin. By default, the scanner is not deleted; if desired, this can be done in custom destructor code (see the parser generator's <strong>code</strong> method).</p>
<p><em>object</em> must be a command; the parser calls this command with <strong>next</strong> as parameter whenever a new terminal needs to be read. The value returned by the command is expected to be a list of length one or two. The first item of this list is considered to be a terminal, and the second item is considered to be the value associated with this terminal. If the list has only one element, the value is assumed to be the empty string. At the end of input, an empty string shall be returned as terminal.</p>
<p>The <strong>ylex</strong> package is designed to provide appropriate scanners for parsing, but it is possible to use custom scanners as long as the above rules are satisfied.</p>
</dd>
<dt><em>objName</em> <strong>configure</strong> <strong>-verbose</strong> ?<em>value</em>?</dt>
<dd><p>If the value of the <strong>verbose</strong> variable is non-zero, the parser prints debug information about the read tokens and matched rules to standard output.</p>
</dd>
<dt><em>objName</em> <strong>configure</strong> <strong>-verbout</strong> ?<em>value</em>?</dt>
<dd><p>Sets the target channel for debug information. The default value is <strong>stderr</strong>.</p>
</dd>
</dl>
<h1>SCRIPTS</h1>
<p>If a rule is matched, its corresponding script is executed in the context of the parser. Scripts have access to the variables <strong>$</strong><em>&lt;i&gt;</em>, which are set to the values associated with each item on the RHS, where <em>&lt;i&gt;</em> is the index of the item. Numbering items is left to right, starting with 1.</p>
<p>Scripts can execute <strong>return</strong> to set their return value, which will then be associated with the rule's LHS. If a script does not execute <strong>return</strong>, the value associated with the the leftmost item on the RHS is used as the rule's value. If the RHS is empty, an empty string is used.</p>
<p><strong>yeti</strong> reserves names with the <strong>yy</strong> prefix, so scripts should not use or access variables with this prefix. Also, a parser's public methods and variables as seen above must be respected.</p>
<h1>EXAMPLE</h1>
<p>Here's one simple but complete example of a parser that can parse mathematical expressions, albeit limited to multiplications. The scanner is not shown, but is expected to return the terminals written in uppercase.</p>
<p>set pgen [yeti::yeti #auto -name MathParser]</p>
<p>$pgen add start {mult} {</p>
<blockquote>
<p>puts "Result is $1"</p>
</blockquote>
<p>}</p>
<p>$pgen add mult {number MULTIPLY number} {</p>
<blockquote>
<p>return [expr $1 * $3]</p>
</blockquote>
<p>}</p>
<p>$pgen add mult {number}</p>
<p>$pgen add number {INTEGER}</p>
<p>$pgen add number {OPEN mult CLOSE} {</p>
<blockquote>
<p>return $2</p>
</blockquote>
<p>}</p>
<p>eval [$pgen dump]</p>
<p>set mp [MathParser #auto -scanner $scanner]</p>
<p>puts "The result is [$mp parse]"</p>
<h1>KEYWORDS</h1>
<p>parser, scanner</p>
</body>
</html><!--Generated by HTMLArk 2021-10-03 18:00:25.523553. Original URL yeti-out.html-->
